API 文档

[](https://quant.10jqka.com.cn/)
- 首页我的策略策略创作策略研究指标策略策略监控策略库因子研究因子策略因子检测因子库绩效分析我的研究实盘交易python策略模拟指标策略模拟同花顺智能交易社区帮助本地SDKAPI 文档因子研究模拟仿真回测引擎研究环境/实盘常见问题因子数据产品智能交易在线文档数据
 全局搜索 [登录](javascript:void(0))[注册](https://upass.10jqka.com.cn/register)API 文档
- 回测引擎专用API[重要！！]写在最前面基本函数init交易频率自动调用函数入口 handle_bartick行情数据变化时调用 handle_tick集合竞价后(9:26)调用一次：open_auction开盘前半小时调用一次：before_trading当天收盘后半小时调用一次：after_trading委托状态更新后的回调函数：on_order有成交后的回调函数：on_trade自定义运行函数设置函数数据函数交易函数枚举常量重要对象辅助函数工具函数股票代码格式转换：normalize_symbol保存文件函数：write_file读取文件函数：read_file查询研究环境指定路径下的文件：list_file复制/剪贴文件或文件夹：copy_file删除文件或文件夹：remove_file消息推送函数：notify_push自选板块：custom_sector通用数据接口行情资金数据证券信息数据表数据问财接口问财接口使用前必读问财实时数据：query_iwencai (研究环境使用，与网页使用一致)问财昨日数据：get_iwencai(回测环境使用)问财接口是否支持本地接口调用？市面ZUI全！一文讲透问财语句深度使用技巧（含50个案例）组合优化器构造组合优化官方交流群注意此群为交流群，如果有疑问请在论坛发帖 ，点此发帖

# API文档

如果您有任何意见建议或者您在使用过程中遇到说明文档中无法解答的问题，您可以:

- 📢在SuperMind官方社区发帖提问交流

- 💌给我们发送邮件： SuperMind@myhexin.com

- 新文档还在不断完善中，想暂时使用旧的版本可以查看：旧的文档

## 回测引擎专用API

目前，SuperMind策略API跟据标的、回测模式不同分为七种类型：

- 股票API：用于股票、场内基金、可转债策略回测

- 股票日内API：用于股票日内回转交易策略回测

- 期货期权API：用于期货期权策略回测

- 股票期货API：用户股票和期货对冲策略的回测

- 场外基金API：用于场外基金申赎策略回测

- 外汇API：用于回测外汇合约策略

- T+D合约API：用于回测延期交收合约策略

### [重要！！]写在最前面

若出现'****'未定义的情况，请先引入包，建议默认都加上，更方便：

```
from mindgo_api import *
​
```

### 基本函数

| function | 股票 | 股票日内 | 期货期权 | 股票期货 | 场外基金 | 外汇 | T+D合约 |
| --- | --- | --- | --- | --- | --- | --- | --- |
| init | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
| handle_bar | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
| handle_tick | ✅ | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ |
| open_auction | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ |
| before_trading | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
| after_trading | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
| on_order | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ |
| on_trade | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ |

- ❗注意事项：

股票策略目前仅在研究环境的回测接口中支持 handle_tick
handle_tick与 handle_bar不能并存

#### init

- 👑调用方法：
def init(context):

- 📚参数说明：

| 参数 | 含义 | 说明 |
| --- | --- | --- |
| context | context对象 | 用来存放当前账户资金、持仓信息等数据 |

- 🔧作用：

初始化函数，进行策略回测与模拟交易时在最开始时执行一次 init，仿真交易在第一次运行策略时执行一次 init
👀️ 特别说明:

仅在策略第一次运行时执行

在研究环境中,使用 research_trade接口执行策略时,第一次运行会在'./persist'路径下生成一个策略同名(用户可自定义传入 research_trade接口)文件夹,用于持久化全局变量。

执行此策略时,如果'./persist'下存在同名路径,则不会执行init

如果要重新执行init

1、删除 './persist'下存在的同名路径；（加入回收站，再清空回收站）

2、或者更改research_trade函数中的策略名称，如下所示：

rtrade = research_trade(
    '要让init重新执行，请更改这个策略名称',
     source_code,
     frequency='MINUTE', 
     trade_api=trade_api,
     signal_mode=False,
     recover_dt='today'
)
​

常见的报错：

因为再init执行过后，添加了信息，所以程序无法识别。用上述方法进行修复。GlobalVars' object has no attribute '****'

用于初始化账户信息、回测参数、全局变量等

❗注意事项：

该函数用于初始化账户,任何一个策略都必须有该函数
在该函数下,你可以设置很多初始条件,例如：基准,交易费,滑点,合约池等等

📝示例：

from mindgo_api import *

def init(context):   
    #设置要交易的标的(平安银行) ,命名的时候注意不要覆盖系统变量
    context.stock = '000001.SZ'
​

#### 交易频率自动调用函数入口 handle_bar

- 👑调用方法：
def handle_bar(context,bar_dict):

- 📚参数说明：

| 参数 | 含义 | 说明 |
| --- | --- | --- |
| context | context对象 | 用来存放当前账户资金、持仓信息等数据 |
| bar_dict | bar_dict对象 | 用于存放当前订阅所有合约的bar行情数据 |

- 🔧作用：

函数用来定时执行买卖条件，每个交易频率（日/分钟）自动调用一次 handle_bar

- ❗注意事项：

尽可能保证此函数中的代码效率，避免在此函数下查询大量数据，特别是在模拟、仿真交易中，避免出现执行时间过长，导致产生延时成本
此函数在非交易时间不会触发(例如1月1日至3日是非交易日，则handle_bar在1日至3日不触发，直到下一个交易日4号触发)
此函数的调用频率根据策略的交易频率确定
在该函数中，可以传入其他函数的运行结果，用来判断买卖条件

- 📝示例：

```
# 每个交易频率买入100股平安银行
def handle_bar(context, bar_dict):
    order('000001.SZ', 100)
​
```

#### tick行情数据变化时调用 handle_tick

- 👑调用方法：
def handle_tick(context,tick):

- 📚参数说明：

| 参数 | 含义 | 说明 |
| --- | --- | --- |
| context | context对象 | 用来存放当前账户资金、持仓信息等数据 |
| tick | tick对象 | 用于存放当前推送合约的tick行情数据 |

- 🔧作用：

当所订阅的股票tick行情数据发生变化时，调用一次 handle_tick函数

- ❗注意事项：

尽可能保证此函数中的代码效率，避免在此函数下查询大量数据，特别是在模拟、仿真交易中，避免出现执行时间过长，导致产生延时成本
当同时订阅了多只股票时，遵循“时间优先，顺序优先”的规则，即首先执行时间戳靠前的股票，如果时间戳一只，则按照订阅列表中的顺序执行
tick行情的更新会自动触发该方法的调用。策略具体逻辑可在该方法内实现，包括交易信号的产生、订单的创建等。在实时模拟交易中，该函数有tick行情则被触发一次
仅在T0策略、股票策略(研究环境)中有效

- 📝示例：

```
# 打印当前推送tick行情的股票代码，并下单买入100股
def handle_tick(context, tick):
    log.info(tick.order_book_id)
    order(tick.order_book_id, 100)
​
```

#### 集合竞价后(9:26)调用一次：open_auction

- 👑调用方法：
def open_auction(context,bar_dict):

- 📚参数说明：

| 参数 | 含义 | 说明 |
| --- | --- | --- |
| context | context对象 | 用来存放当前账户资金、持仓信息等数据 |
| bar_dict | bar_dict对象 | 用于存放当前订阅所有合约的bar行情数据 |

- 🔧作用：

集合竞价后(9:26)，调用一次 open_auction函数

- ❗注意事项：

尽可能保证此函数中的代码效率，特别是在模拟、仿真交易中，避免出现执行时间过长
在回测、模拟交易中，在此阶段下单会使用集合竞价成交数据对订单进行撮合，可用于回测集合竞价策略；但在仿真交易中，此时下的订单会在9:30进行撮合
仅在股票策略中有效

- 📝示例：

```
# 下单买入100股平安银行
def open_auction(context, bar_dict):
    order('000001.SZ', 100)
​
```

#### 开盘前半小时调用一次：before_trading

- 👑调用方法：
def before_trading(context):

- 📚参数说明：

| 参数 | 含义 | 说明 |
| --- | --- | --- |
| context | context对象 | 用来存放当前账户资金、持仓信息等数据 |

- 🔧作用：

当天开盘前半小时调用一次 before_trading，常用于使用前日数据计算因子、信号；储存自定义参数、全局变量等

- ❗注意事项：

该函数在回测中的非交易日不触发
在该函数中，你可以自由储存自定义函数的运行结果、全局变量数据等,并在 handle_bar等函数中使用

- 📝示例：

```
# 每个交易日开市前，打印出目前的账户信息.
def before_trading(context):
    log.info(context.portfolio)
​
```

#### 当天收盘后半小时调用一次：after_trading

- 👑调用方法：
def after_trading(context):

- 📚参数说明：

| 参数 | 含义 | 说明 |
| --- | --- | --- |
| context | context对象 | 用来存放当前账户资金、持仓信息等数据 |

- 🔧作用：

当天收盘后半小时调用一次 after_trading，常用于跟据前日数据计算；储存自定义参数、全局变量等

- ❗注意事项：

该函数在回测中的非交易日不触发
在该函数中，你可以自由储存自定义函数的运行结果、全局变量数据等，用来总结今日的交易，并计划明天的交易

- 📝示例：

```
#交易日结束后，打印组合盈亏
def after_trading(context):
    log.info(context.portfolio.pnl)
​
```

#### 委托状态更新后的回调函数：on_order

- 👑调用方法：
def on_order(context,odr):

- 📚参数说明：

| 参数 | 含义 | 说明 |
| --- | --- | --- |
| context | context对象 | 用来存放当前账户资金、持仓信息等数据 |
| odr | order委托对象 | 委托详情 |

- 🔧作用：

委托状态更新后的回调函数

- ❗注意事项：

回测时下单后立刻触发，仿真交易时会在handle_bar执行完后触发

- 📝示例：

```
#交易日结束后，打印组合盈亏
def on_order(context,odr):
    log.info(odr)
​
```

#### 有成交后的回调函数：on_trade

- 👑调用方法：
def on_trade(context,trade):

- 📚参数说明：

| 参数 | 含义 | 说明 |
| --- | --- | --- |
| context | context对象 | 用来存放当前账户资金、持仓信息等数据 |
| trade | trade成交对象 | 委托详情 |

- 🔧作用：

有成交后的回调函数

- ❗注意事项：

回测时下单后立刻触发，仿真交易时会在handle_bar执行完后触发

- 📝示例：

```
#交易日结束后，打印组合盈亏
def on_trade(context,trade):
    log.info(trade)
​
```

### 自定义运行函数

#### 每日定时运行函数：run_daily

- 👑调用方法：
run_daily(func, time_rule, hours, minutes, reference_security)

- 🔧作用：

每日定时运行函数，如需指定时间运行，需要在分钟级策略使用该函数

- 📚参数说明：

func：需要执行的函数
time_rule：时间计算规则，可选三种传入值：'after_open'、'before_close'和 'every_bar'

'after_open'：开盘后（之后的两个参数hours和minutes可设置开盘后多久运行，取值范围为1分钟至4小时）
'before_close'：收盘前（之后的两个参数hours和minutes可设置收盘前多久运行，取值范围为1分钟至4小时）
'every_bar'：每分钟都会运行（无需再额外传入hours和minutes参数）

hours：运行时间(小时)
minutes ：运行时间(分钟)
reference_security ：参考标的选取，确定交易时间

若参考标的为股票,例如:reference_security= '000001.SZ', 则交易时间为9:30-15:00-
若参考标的为股指期货,例如: reference_security= 'IC1508'，则交易时间分为9:15-15:15和9:30-15:00两种,以20160101划分
默认为股票

- ❗注意事项：

如果在日频策略中使用该函数，不需要传入 time_rule, hours, minutes，默认在9点31分执行，实际和日频 handle_bar效果相同
此函数中 reference_security参数不填写，则自动默认为股票标的
此函数中 reference_security参数，如果以股票为标的，则传入任何一个股票代码都是可以的，期货同理
该函数的 time_rule参数，如果填写 'every_bar'，则不需要填写 hours和 minutes两个参数，如果填写了，是无效的，不会报错，也不影响运行

- 📝示例：

示例一

def init(context):
# 每个交易日开盘后30分执行一次
    run_daily(func=test_day, time_rule='after_open', hours=0, minutes=30, reference_security='000856.SZ')

def test_day(context, bar_dict):
    log.info('定时运行')
​

#### 每周定时运行函数：run_weekly

- 👑调用方法：
run_weekly(func, date_rule, reference_security)

- 📚参数说明：

| 参数 | 含义 | 说明 |
| --- | --- | --- |
| func | 执行的函数 | 一般为自定义函数，实现特定目标 |
| date_rule | 时间计算规则 | date_rule为正数(取值范围为[1,5])表示为每周的第几个交易日，负数(取值范围为[-5,-1])表示为每周倒数第几个交易日 |
| reference_security | 参考标的选取，确定交易时间 | - 若参考标的为股票,例如:reference_security= '000001.SZ', 则交易时间为9:30-15:00- 若参考标的为股指期货,例如: reference_security= 'IC1508'，则交易时间分为9:15-15:15和9:30-15:00两种,以20160101划分- 默认为股票 |

- 🔧作用：

每周定时运行函数,指定日开盘时运行

- ❗注意事项：

该函数既可以用于分钟级策略，也可以用于日级策略
此函数中 reference_security参数不填写，则自动默认为股票标的
此函数中 reference_security参数，如果以股票为标的，则传入任何一个股票代码都是可以的，期货同理
该函数的 date_rule参数，必须填写(取值范围为1至5或-5至-1),如果大于5,则会报错.如果小于-5,策略会继续运行,但是该函数不生效

- 📝示例：

示例一

def init(context):
    # 每周第一个交易日执行
    run_weekly(func=test_week, date_rule=1, reference_security='000001.SZ')

def test_week(context, bar_dict):
    log.info('定时运行')
​

#### 每月定时运行函数：run_monthly

- 👑调用方法：
run_monthly(func, date_rule, reference_security)

- 📚参数说明：

| 参数 | 含义 | 说明 |
| --- | --- | --- |
| func | 执行的函数 | 一般为自定义函数，实现特定目标 |
| date_rule | 时间计算规则 | date_rule为正数(取值范围为[1,23])表示为每月的第几个交易日，负数(取值范围为[-23,-1])表示为每月倒数第几个交易日 |
| reference_security | 参考标的选取，确定交易时间 | - 若参考标的为股票,例如:reference_security= '000001.SZ', 则交易时间为9:30-15:00- 若参考标的为股指期货,例如: reference_security= 'IC1508'，则交易时间分为9:15-15:15和9:30-15:00两种,以20160101划分- 默认为股票 |

- 🔧作用：

每月定时运行函数,指定日开盘时运行

- ❗注意事项：

该函数既可以用于分钟级策略，也可以用于日级策略
此函数中 reference_security参数不填写，则自动默认为股票标的
此函数中 reference_security参数，如果以股票为标的，则传入任何一个股票代码都是可以的，期货同理
该函数的 date_rule参数，必须填写(取值范围为1至23或-23至-1),输入数值超出范围,则会报错

- 📝示例：

示例一

def init(context):
    # 每月第5个交易日执行
    run_monthly(func=test_month, date_rule=5, reference_security='000001.SZ')

def test_month(context, bar_dict):
    log.info('定时运行')
​

### 设置函数

#### 设置基准收益：set_benchmark

- 👑调用方法：
set_benchmark(symbol)

- 📚参数说明：

| 参数 | 含义 | 说明 |
| --- | --- | --- |
| symbol | 股票或者其他品种代码 | 例如：沪深300：'000300.SH', 国债ETF: '511010.OF' |

- 🔧作用：

set_benchmark函数用于设置基准收益, 其不影响策略的运行

- ❗注意事项：

该函数是设置函数, 属于初始设置条件, 必须在 init(context)函数下设置, 否则都是无效的
该函数的 symbol参数, 必须输入字符串, 且只能输入一个代码, 例如: ['000300.SH']是错的, '000300.SH'是对的
如果整个策略没有该函数, 则默认策略的基准为沪深300指数

- 📝示例：

def init(context):
    #初始化策略时设置基准为沪深300指数
    set_benchmark('000300.SH')
​

#### 设置策略滑点：set_slippage

- 👑调用方法：
set_slippage(slippage)

- 📚参数说明：

slippage:PriceSlippage或FixedSlippage对象

PriceSlippage：可变滑点对象，例如PriceSlippage(0.1)，表示买入价为实际价格乘1.05，卖出价为实际价格乘0.95
FixedSlippage：固定滑点对象，例如FixedSlippage(10)，表示买入价为实际价格加5，卖出价为实际价格减5

- 🔧作用：

set_slippage函数用于设置策略滑点, 其不影响策略的运行，默认为0.002的可变滑点

- ❗注意事项：

该函数是设置函数, 属于初始设置条件, 必须在 init(context)函数下设置, 否则是无效的

- 📝示例：

def init(context):
    #设置可变滑点2%，表示买入价为实际价格乘101%，卖出价为实际价格乘99%
    set_slippage(PriceSlippage(0.02))
​

#### 设置交易手续费：set_commission

- 👑调用方法：
set_commission(cal_style)

- 📚参数说明：

cal_style:PerShare或PerTrade对象

PerShare：比例交易手续费，例如 PerShare(type='stock',cost=0.0002)，表示手续费为交易额的0.02%
PerTrade：固定交易手续费，例如 PerTrade(type='future',cost=5.0)，表示每笔交易手续费5元

- 🔧作用：

set_commission函数用来设置交易手续费，其不影响策略的运行,默认交易手续费为：交易额的0.02%

- ❗注意事项：

该函数必须在 init(context)函数下设置, 否则无效

- 📝示例：

def init(context):
    #设置股票手续费为交易额的0.01%(万一)，最低手续费为0元(免5)
    set_commission(PerShare(type='stock',cost=0.0001,min_trade_cost=0.0))
​

#### 设置回测策略账户初始持仓：set_holding_stocks

- 👑调用方法：
set_holding_stocks(holdings)

- 📚参数说明：

holdings:dict对象，key为持仓的symbol，value为持仓的数量(必须为正整数)

- 🔧作用：

set_holding_stocks函数用来设置回测策略账户初始持仓(设置初始持仓并不会减少账户的初始资金)

- ❗注意事项：

若进行策略回测, 则该函数默认使用回测开始日期的前一个交易日收盘价持有初始持仓
若回测起始日期小于等于所添加股票的上市日期或股票已经退市, 则无法添加该股票持仓
该函数必须在init函数下设置,否则是无效的

- 📝示例：

def init(context):
    #设置策略初始持仓
    set_holding_stocks({'000001.SZ': 200,'300033.SZ': 500,'600519.SH': 700})
​

#### 设置设置子账户：set_subportfolios

- 👑调用方法：
set_subportfolios([dict_1,dict_2,...])

- 📚参数说明：

dict_1:dict对象，key为 cash、type的字典

cash:子账户初始资金,例如:'cash':500000,设置子账户初始资金为50万
type:子账户类型,例如： 'type': 'future',设置该子账户为期货账户.配合'cash'一起使用:{'cash':500000,'type':'future'}

- 🔧作用：

set_subportfolios函数用来设置设置子账户

- ❗注意事项：

该函数设置后，子账户初始资金之和必须等于总的初始资金(回测时需要填写总的初始资金)
模拟交易时，函数设置的期货和股票账户资金必须对应模拟交易中期货和股票账户的资金。设置函数或者创建模拟账户时,必须考虑到这点,不然无法正常模拟交易
如果整个策略没有该函数,则无法进行期货交易
该函数必须在init函数下设置,否则是无效的

- 📝示例：

def init(context):
    #设置子账户,股票账户50万，期货账户50万.
    set_subportfolios([{'cash':500000,'type':'stock'},{'cash':500000,'type':'future'}])
​

#### 设置最大成交比例：set_volume_limit

- 👑调用方法：
set_volume_limit(daily, minute)

- 📚参数说明：

daily:float，例如 daily=0.25,则意味着下单数量超过日线级成交量25%的部分无法成交；daily=None,则表示不做成交量限制
minute:float，例如 minute=0.5,则意味着下单数量超过分钟线级成交量50%的部分就无法成交；minute=None,则表示不做成交量限制

- 🔧作用：

set_volume_limit函数用来设置最大成交比例,若下单数量超过当前时间周期的成交量一定比例，则按允许的最大数量成交

- ❗注意事项：

如果策略没有该函数，则默认daily=0.25，minute=0.5
该函数设置后，一旦触发，则本次下单可能会部分成交

- 📝示例：

def init(context):
    #设置最大成交比例日级成交量比例50%,分钟级成交量比例50%
    set_volume_limit(daily=0.5, minute=0.5)
​

#### 设置下单后延迟成交时间：set_trade_delay

- 👑调用方法：
set_trade_delay(delay_time)

- 📚参数说明：

delay_time:int，延迟delay_time个bar后成交，例如 delay_time=5

在日级回测中下单后，延迟5个交易日成交
在分钟级回测中下单后，推迟5分钟成交

- 🔧作用：

设置下单后延迟成交时间

- ❗注意事项：

该函数在模拟交易中无效，只能在回测环境中使用它
该函数必须在init(context)函数下设置,否则无效

- 📝示例：

def init(context):
    #下单后推迟3分钟/交易日成交
    set_trade_delay(delay_time=3)
​

#### 设置log输出级别：set_log_level

- 👑调用方法：
set_log_level(level,is_limit=True,filename=None)

- 📚参数说明：

level:str，log对应的级别，如果设定level为'warn',则log打印函数只会打印'warn'、'error'级别
is_limit:bool,日志数量限制，默认True为10000条
filename:str，重定向日志文件路径(仅研究平台有效)

- 🔧作用：

set_log_level函数用来设置log输出级别,log打印一般有三种log.info()、log.warn()、log.error(),优先级排序为：error>warn>info

- ❗注意事项：

该函数不仅可以在 init(context)函数下设置,也可以在 handle_bar(context, bar_dict)函数下设置
当log.error()打印数据时,整个回测就会停止,类似一个报错终止机制

- 📝示例：

def init(context):
    #设置日志级别:warn
    set_log_level(level='warn')
​

#### 设置回测成交机制：set_execution

- 👑调用方法：
set_execution(str)

- 📚参数说明：

str:撮合成交机制，可选'close','next_open'

'close':当前bar收盘价撮合
'next_open':下一个bar开盘价撮合

- 🔧作用：

set_execution函数用来设置回测成交机制, 不同的设置会采用不同的价格进行撮合成交(只在分钟回测中有效，默认next_open)

- ❗注意事项：

该函数必须在 init(context)函数下设置, 否则无效
该函数的str参数, 必须输入字符串, 且只能输入一个，例如: set_execution('next_open')
如果整个策略没有该函数, 则默认策略采用next_open模式进行回测

- 📝示例：

```
def init(context):
    #初始化策略时设置撮合机制为下一个bar的open
    set_execution('next_open')
​
```

#### 调整handle_bar运行时间：enable_open_bar

- 👑调用方法：
enable_open_bar()

- 🔧作用：

该函数在init调用，功能为在股票日级回测中，handle_bar执行时间调整为9:30；在分钟级回测中，handle_bar在9:30增加一次运行

- 📝示例：

# 股票策略模版
# 初始化函数,全局只运行一次
def init(context):
    enable_open_bar()

#每日开盘前9:00被调用一次,用于储存自定义参数、全局变量,执行盘前选股等
def before_trading(context):
    pass

## 开盘时运行函数
def handle_bar(context, bar_dict):
    order("300033.SZ", 100)

## 收盘后运行函数,用于储存自定义参数、全局变量,执行盘后选股等
def after_trading(context):
    pass
​

#### 定义列式计算的信号名以及计算方式：reg_signal

- 👑调用方法：
reg_signal(name,func)

- 📚参数说明：

name:指标计算名称
func:指标的计算方式,定义方式为 def func(data):,data代表订阅的tick数据,格式为pd.DataFrame,返回值为一个索引与data对齐的pd.Series

- 🔧作用：

定义列式计算的信号名以及计算方式

- ❗注意事项：

若订阅了多只股票，则对每只股票分别进行计算
需要与get_signal配合使用

- 📝示例：

```
#定义一个名为’big’的信号，算法为tick数据大于10等于True，否则等于False.
def init(context):
    reg_signal('big',get_big)

def get_big(data):
    return data[‘current’]>10
​
```

#### 设置某一品种的保证金比例：set_margin_rate

- 👑调用方法：
set_margin_rate(symbol,long_value,short_value)

- 📚参数说明：

symbol:标的代码
long_value:做多保证金比例
short_value:做空保证金比例

- 🔧作用：

- 该函数用于设置某一品种的保证金比例

- 📝示例：

# 设置螺纹钢的保证金比例为9%
def init(context):
    set_margin_rate('RB',0.09,0.09)
​

#### 设置期权手续费：set_option_commission

- 👑调用方法：
set_option_commission(cost)

- 📚参数说明：

cost:单张期权合约的手续费(元)

- 🔧作用：

该函数设置期权手续费（元/单张10000份），默认为5元

- ❗注意事项：

该函数必须在 init(context)函数下设置, 否则无效

- 📝示例：

# 设置期权手续费为10元/张
def init(context):
    set_option_commission(10)
​

#### 设置期权交易滑点：set_option_slippage

- 👑调用方法：
set_option_slippage(rate)

- 📚参数说明：

rate:设置的期权交易浮动滑点比例

- 🔧作用：

该函数设置期权交易滑点, 其不影响策略的运行，默认为0.001

- ❗注意事项：

该函数必须在 init(context)函数下设置, 否则无效

- 📝示例：

# 设置期权交易滑点为双边0.004(单边0.002)
def init(context):
    set_option_slippage(0.004)
​

#### 设置场外基金申购折扣率：set_discount_rate

- 👑调用方法：
set_discount_rate(rate)

- 📚参数说明：

rate:基金申购折扣率，在0到1之间，默认为0.1

- 🔧作用：

该函数设置场外基金申购折扣率

- ❗注意事项：

该函数必须在 init(context)函数下设置, 否则无效

- 📝示例：

def init(context):
    # 初始化策略时设置折扣率10%
    set_discount_rate(0.1)
​

#### 设置场外基金申购折扣率：set_dividend_mode

- 👑调用方法：
set_dividend_mode(mode)

- 📚参数说明：

mode:基金分红处理模式，可选 cash/invest

cash:现金分红
invest:红利再投资

- 🔧作用：

该函数设置场外基金申购折扣率

- ❗注意事项：

该函数必须在 init(context)函数下设置, 否则无效
如果未设置，系统默认为红利再投资

- 📝示例：

def init(context):
    #初始化策略时设置分红模式为红利再投资
    set_dividend_mode(invest)
​

### 数据函数

- 此部分数据接口仅可在策略回测以及模拟交易中调用，其他地方无法调用，需使用通用数据接口

#### 订阅标的：subscribe

- 👑调用方法：
subscribe(id_or_symbols)

- 📚参数说明：

id_or_symbols:需要订阅的标的代码，支持单个订阅(str)或多个订阅(list)

- 🔧作用：

订阅标的，使合约池内合约增加

- ❗注意事项：

策略会根据订阅的标的所属的交易所交易时间的并集确定策略执行 handle_bar、before_trading、after_trading运行时间，默认为沪深交易所时间
在tick级回测中必须订阅合约，否则不会触发tick行情事件
在外汇(双向宝)策略中必须订阅合约
在T+D合约策略中必须订阅合约

- 📝示例：

def init(context):
    #订阅螺纹主力合约
    subscribe('RB9999')
​

#### 取消订阅标的：unsubscribe

- 👑调用方法：
unsubscribe(id_or_symbols)

- 📚参数说明：

id_or_symbols:需要订阅的标的代码，支持单个订阅(str)或多个订阅(list)

- 🔧作用：

取消订阅标的，使合约池内合约减少

- 📝示例：

def init(context):
    #订阅螺纹主力合约
    subscribe('RB9999')

def after_trading(context):
    #取消订阅螺纹主力合约
    unsubscribe('RB9999')
​

#### 获取当前bar的时间：get_datetime

- 👑调用方法：
get_datetime()

- 🔧作用：

获取当前bar的时间

- ❗注意事项：

该函数没有参数，直接使用
在tick级策略中使用时，返回当前交易日的开盘时间

- 📝示例：

from datetime import timedelta as td

def init(context):
    pass 

def handle_bar(context,bar_dict):
    # 获取当前bar的时间
    time = get_datetime()
    log.info(time)
    # 获取回测前一天日期
    yesterday_time = get_datetime()-td(days=1)
    yesterday_date = yesterday_time.strftime("%Y%m%d")
    log.info(yesterday_date)
​

#### 获取上一个bar的时间：get_last_datetime

- 👑调用方法：
get_last_datetime()

- 🔧作用：

获取上一个bar的时间

- ❗注意事项：

该函数没有参数，直接使用
在tick级策略中使用时，返回前一交易日的收盘时间

- 

- 📝示例：

```
def init(context):
    pass 

def handle_bar(context,bar_dict):
    # 获取上一个bar的时间
    last_datetime = get_last_datetime()
    log.info('回测前一个handle_bar调用时间：'+str(last_datetime))
​
```

- 返回数据：

pandas.Timestamp格式.
例如:2016-08-08 09:30:00

2016-08-08 09:30:00 - INFO
回测当天时间：2016-08-08 09:30:00
2016-08-08 09:30:00 - INFO
回测前一天时间：20160807
​

#### 获取股票历史行情：history

- 🔧作用：

获取股票多属性的历史行情数据,仅可在策略API内使用

- 👑调用方法：

history(
    symbol_list,
    fields,
    bar_count, 
    fre_step,
    skip_paused = False,
    fq = 'pre',
)
​

- 📚参数说明：

- symbol_list:str或list，标的代码,取单个股票数据时可以传入字符串，若需要取多个标的，需传入列表

- fields:list,数据字段,支持字段可参考A股日行情数据、A股分钟行情数据

- bar_count:历史长度，例如 bar_count = 5，表示获取过去5个时间步长的历史数据

- fre_step:时间步长'Xd'/'Xm',X必须为正整数，fre_step = '1d'表示时间步长为1天

当X不等于1时，field仅支持'open','high','low','close','volume','turnover'这几个字段

- skip_paused:是否跳过停牌数据

skip_paused = True:跳过停牌数据
skip_paused = False:不跳过停牌数据

- fq:复权选项,可选不复权、前复权、后复权，默认不复权

fq = None：不复权
fq = 'pre'：前复权，动态复权模式，以当前bar的最新价作为基准向前复权，详情可参考拆分、合并与分红
fq = 'post'：后复权

- ❗注意事项：

由于策略框架的运行机制，取日频历史行情时，不包含当前bar的数据；取分钟频历史行情，包含当前bar数据

- 📝示例：

def init(context):
    pass

def handle_bar(context,bar_dict):
    #获取万科A与平安银行过去10日的收盘价与最高价，并且输出数据
    price=history(['000001.SZ','000002.SZ'], ['close','high'], 10, '1d', False, 'pre')
    log.info('收盘价：'+str(price['close']))
    log.info('最高价：'+str(price['high'])
​

- 返回数据：

返回dict对象，其key是symbol即证券代码、值是pandas.Dataframe，行索引是datetime.datetime对象，列索引是字段名称。
​
【示例1】返回结果：
2017-01-03 09:30:00 - INFO
收盘价：        000001.SZ  000002.SZ
2016-12-19       9.20      21.10
2016-12-20       9.11      20.33
2016-12-21       9.16      20.48
2016-12-22       9.14      20.61
2016-12-23       9.08      20.30
2016-12-26       9.12      20.65
2016-12-27       9.08      21.42
2016-12-28       9.06      21.20
2016-12-29       9.08      20.84
2016-12-30       9.10      20.55
2017-01-03 09:30:00 - INFO
最高价：        000001.SZ  000002.SZ
2016-12-19       9.23      22.00
2016-12-20       9.20      21.00
2016-12-21       9.16      20.70
2016-12-22       9.16      20.77
2016-12-23       9.14      20.67
2016-12-26       9.13      20.69
2016-12-27       9.13      21.98
2016-12-28       9.11      21.48
2016-12-29       9.09      21.32
2016-12-30       9.10      20.96

【示例2】返回结果：
2017-01-03 09:30:00 - INFO
300033.SZ开盘价：    open
2016-12-27 13:59:00  69.00
2016-12-27 14:59:00  68.50
2016-12-28 10:29:00  68.12
2016-12-28 11:29:00  68.69
2016-12-28 13:59:00  68.49
2016-12-28 14:59:00  68.55
2016-12-29 10:29:00  68.90
2016-12-29 11:29:00  68.81
2016-12-29 13:59:00  70.20
2016-12-29 14:59:00  70.11
2017-01-03 09:30:00 - INFO
600519.SH开盘价：    open
2016-12-27 13:59:00  328.30
2016-12-27 14:59:00  326.55
2016-12-28 10:29:00  326.99
2016-12-28 11:29:00  326.00
2016-12-28 13:59:00  325.19
2016-12-28 14:59:00  325.40
2016-12-29 10:29:00  324.01
2016-12-29 11:29:00  323.70
2016-12-29 13:59:00  325.80
2016-12-29 14:59:00  325.80
​

#### 获取期货历史行情：history_future

- 🔧作用：

获取期货多属性的历史行情数据,仅可在策略API内使用

- 👑调用方法：

history_future(
    symbol_list,
    fields,
    bar_count, 
    fre_step,
    is_panel=0
)
​

- 📚参数说明：

symbol_list:str或list，标的代码,取单个合约数据时可以传入字符串，若需要取多个合约，需传入列表
fields:list,数据字段,支持字段可参考期货日行情数据、期货分钟行情数据
bar_count:历史长度，例如 bar_count = 5，表示获取过去5个时间步长的历史数据
fre_step:时间步长'Xd'/'Xm',X必须为正整数，fre_step = '1d'表示时间步长为1天

当X不等于1时，field仅支持'open','high','low','close','volume','turnover'这几个字段

is_panel:返回数据格式是否为panel，默认 is_panel = 0

is_panel = 0: 返回 dict对象，其key是symbol即证券代码、值是 pandas.Dataframe，行索引是 datetime.datetime对象，列索引是字段名称
is_panel = 1: 返回 Panel对象，key为fileds字段。Panel为 pandas.DataFrame的三维结构，选定字段后输出的便是 pandas.DataFrame对象

- ❗注意事项：

由于策略框架的运行机制，取日频历史行情时，不包含当前bar的数据；取分钟频历史行情，包含当前bar数据

- 📝示例：

def init(context):
    #设定期货品种代码
    context.symbol = ['RB9999']

def handle_bar(context,bar_dict):
    price=history_future(context.symbol, ['close','high'], 10, '1d', is_panel=0)
    log.info(price)
​

#### 获取历史tick行情快照：history_ticks

- 🔧作用：

获取历史tick行情快照数据,仅可在策略API内使用

- 👑调用方法：

history_ticks(
    symbol_list,
    fields,
    bar_count, 
    is_panel=0
)
​

- 📚参数说明：

symbol_list:str或list，标的代码,取单个合约数据时可以传入字符串，若需要取多个合约，需传入列表
fields:list,数据字段,支持字段可参考历史行情快照数据
bar_count:历史长度，例如 bar_count = 5，表示获取过去5个时间步长的历史数据
is_panel:返回数据格式是否为panel，默认 is_panel = 0

is_panel = 0: 返回 dict对象，其key是symbol即证券代码、值是 pandas.Dataframe，行索引是 datetime.datetime对象，列索引是字段名称
is_panel = 1: 返回 Panel对象，key为fileds字段。Panel为 pandas.DataFrame的三维结构，选定字段后输出的便是 pandas.DataFrame对象

- ❗注意事项：

只能在tick级策略中使用

- 📝示例：

def init(context):
    #设定标的代码
    context.symbol = ['000001.SZ']
    subscribe(context.symbol)

def handle_tick(context,tick):
    price=history_ticks(context.symbol, ['open','prev_close'], 10, is_panel=0)
    log.info(price)
​

### 交易函数

#### 股票

##### 下单函数，根据数量下单：order

- 👑调用方法：
order(id_or_ins, amount, price=None)

- 🔧作用：

下单函数,根据数量下单

- 📚参数说明：

id_or_ins：合约代码，str
amount：下单数量，int，负数为卖出
price：限价单价格上界，float

- ❗注意事项：

下单失败可能由于如下原因

标的不存在
可用资金不足或可用持仓不足

下单设置和实际下单存在差异，会在日志中添加警告信息

买入股票时，下单数量受到当前账户可用资金的限制
卖出股票时，下单数量受到持仓可卖数量的影响

下单数量为0时，会在日志中添加警告信息

- 📝示例：

def init(context):   
    #设置要交易的股票(沪深300ETF）   
    g.index = '510300.OF'

#设置买卖条件，每个交易频率（日/分钟）调用一次   
def handle_bar(context, bar_dict):
    #开仓买入1手沪深300ETF
    order(g.index, 100,price=2.8)
​

##### 下单函数，根据金额下单：order_value

- 👑调用方法：
order_value(id_or_ins, cash_amount, price=None)

- 🔧作用：

下单函数,根据金额下单

- 📚参数说明：

id_or_ins：合约代码，str
cash_amount：下单金额，float，负数为卖出
price：限价单价格上界，float

- ❗注意事项：

下单失败可能由于如下原因

标的不存在
可用资金不足或可用持仓不足

下单设置和实际下单存在差异，会在log中添加警告信息

买入股票时，下单数量受到当前账户可用资金的限制
卖出股票时，下单数量受到持仓可卖数量的影响

- 📝示例：

def init(context):   
    #设置要交易的股票(沪深300ETF）   
    g.index = '510300.OF'

#设置买卖条件，每个交易频率（日/分钟）调用一次   
def handle_bar(context, bar_dict):
    #开仓买入10万元沪深300ETF
    order_value(g.index,100000,price=2.8)
​

##### 下单函数，根据比例下单：order_percent

- 👑调用方法：
order_percent(id_or_ins, percent, price=None)

- 🔧作用：

下单函数,根据当前总资产比例确定下单金额

- 📚参数说明：

id_or_ins：合约代码，str
percent：下单比例，float，负数为卖出
price：限价单价格上界，float
style：LimitOrder对象或MarketOrder对象

LimitOrder对象：限价单，是一种以等同或低於指定价格买进相应数量股票的委托单
MarketOrder对象：市价单，以市场价格买进或卖出股票的委托单

- ❗注意事项：

下单失败可能由于如下原因

标的不存在
可用资金不足或可用持仓不足

下单设置和实际下单存在差异，会在log中添加警告信息

买入股票时，下单数量受到当前账户可用资金的限制
卖出股票时，下单数量受到持仓可卖数量的影响

- 📝示例：

def init(context):   
    #设置要交易的股票(沪深300ETF）   
    g.index = '510300.OF'

#设置买卖条件，每个交易频率（日/分钟）调用一次   
def handle_bar(context, bar_dict):
    #开仓买入1成仓位的沪深300ETF
    order_percent(g.index,0.1,price=2.8)
​

##### 下单函数，根据目标持仓下单：order_target

- 👑调用方法：
order_target(id_or_ins, amount, price=None)

- 🔧作用：

下单函数,根据目标持仓数量确定下单数量

- 📚参数说明：

id_or_ins：合约代码，str
amount：目标持仓数量，int
price：限价单价格上界，float

- ❗注意事项：

下单失败可能由于如下原因

标的不存在
可用资金不足或可用持仓不足

下单设置和实际下单存在差异，会在log中添加警告信息

买入股票时，下单数量受到当前账户可用资金的限制
卖出股票时，下单数量受到持仓可卖数量的影响

- 📝示例：

def init(context):   
    #设置要交易的股票(沪深300ETF）   
    g.index = '510300.OF'

#设置买卖条件，每个交易频率（日/分钟）调用一次   
def handle_bar(context, bar_dict):
    #调仓至持有1000份沪深300ETF
    order_target(g.index,1000,price=2.8)
​

##### 下单函数，根据目标持有金额下单：order_target_value

- 👑调用方法：
order_target_value(id_or_ins, cash_amount, price=None)

- 🔧作用：

下单函数,根据目标持有的金额确定下单数量

- 📚参数说明：

id_or_ins：合约代码，str
cash_amount：目标持仓金额，float
price：限价单价格上界，float

- ❗注意事项：

下单失败可能由于如下原因

标的不存在
可用资金不足或可用持仓不足

下单设置和实际下单存在差异，会在log中添加警告信息

买入股票时，下单数量受到当前账户可用资金的限制
卖出股票时，下单数量受到持仓可卖数量的影响

- 📝示例：

def init(context):   
    #设置要交易的股票(沪深300ETF）   
    g.index = '510300.OF'

#设置买卖条件，每个交易频率（日/分钟）调用一次   
def handle_bar(context, bar_dict):
    #调仓至持有100000元市值沪深300ETF
    order_target_value(g.index,100000,price=2.8)
​

##### 下单函数，根据目标持仓比例下单：order_target_percent

- 👑调用方法：
order_target_percent(id_or_ins, percent, price=None)

- 🔧作用：

下单函数,根据目标持仓比例确定下单数量

- 📚参数说明：

id_or_ins：合约代码，str
percent：目标持仓比例，float
price：限价单价格上界，float

- ❗注意事项：

下单失败可能由于如下原因

标的不存在
可用资金不足或可用持仓不足

下单设置和实际下单存在差异，会在log中添加警告信息

买入股票时，下单数量受到当前账户可用资金的限制
卖出股票时，下单数量受到持仓可卖数量的影响

- 📝示例：

def init(context):   
    #设置要交易的股票(沪深300ETF）   
    g.index = '510300.OF'

#设置买卖条件，每个交易频率（日/分钟）调用一次   
def handle_bar(context, bar_dict):
    #调仓至持有1成仓位沪深300ETF
    order_target_percent(g.index,0.1,price=2.8)
​

##### 获得委托详情：get_orders

- 👑调用方法：
get_orders(order_id)

- 🔧作用：

查询函数,用于获得委托详情，返回order订单对象的列表，若不传入订单id，则返回当天所有委托的order订单对象的列表

- 📚参数说明：

order_id:订单编号，由下单函数返回

- ❗注意事项：

该函数用来获取订单详情，随后将id放入get_orders(id)

- 📝示例：

def init(context):   
    pass

#设置买卖条件，每个交易频率（日/分钟）调用一次   
def handle_bar(context, bar_dict):
    odr_id=order('000001.SZ',200)
    log.info(get_orders(odr_id))
​

##### 获取当日所有未完成委托详情：get_open_orders

- 👑调用方法：
get_open_orders(order_id)

- 🔧作用：

查询函数,用于获取当日所有未完成委托详情，返回order订单对象的list，若传入订单id，则返回对应委托的order订单对象

- 📚参数说明：

order_id:订单编号，由下单函数返回

- ❗注意事项：

一般回测时，下单都是全部完全的，因此该函数适合用于模拟交易/仿真交易中

- 📝示例：

def init(context):   
    pass

#设置买卖条件，每个交易频率（日/分钟）调用一次   
def handle_bar(context, bar_dict):
    odr_id_1=order('000001.SZ',200)
    odr_id_2=order('600519.SH',200)
    log.info(get_open_orders())
​

##### 获取当日所有成交详情：get_tradelogs

- 👑调用方法：
get_tradelogs()

- 🔧作用：

查询函数,用于获取当日所有成交详情，返回trade成交对象的list

- 📝示例：

def init(context):   
    pass

#设置买卖条件，每个交易频率（日/分钟）调用一次   
def handle_bar(context, bar_dict):
    odr_id_1=order('000001.SZ',200)
    odr_id_2=order('600519.SH',200)
    log.info(get_tradelogs())
​

##### 撤销未完成委托订单：cancel_order

- 👑调用方法：
cancel_order(order)

- 🔧作用：

撤单函数,用于撤销未完成委托订单

- 📚参数说明：

order:可以是order订单对象，也可以是订单id

- ❗注意事项：

若订单处于不可撤销的状态，此函数会报错，可配合try关键字使用

- 📝示例：

def init(context):
    pass

def handle_bar(context,bar_dict):
    # 以开盘价买入平安银行股票1000股  
    id=order('000001.SZ', 1000)
    # 获取所有未完成订单
    orders = get_open_orders(id)
    #如果有未完成的则orders长度必定大于0，否则就是已经完成.
    if len(orders)>0:
        #取消未完成订单
        cancel_order(orders)
​

##### 撤销所有未完成委托订单：cancel_order_all

- 👑调用方法：
cancel_order_all()

- 🔧作用：

撤单函数,用于撤销所有未完成委托订单

- 📝示例：

def init(context):
    pass

def handle_bar(context,bar_dict):
    # 以开盘价买入平安银行股票1000股  
    id=order('000001.SZ', 1000)
    # 获取所有未完成订单
    orders = get_open_orders(id)
    #如果有未完成的则orders长度必定大于0，否则就是已经完成.
    if len(orders)>0:
        #取消所有未完成订单
        cancel_order_all()
​

#### 期货

##### 下单函数，根据数量下单：order_future

- 👑调用方法：
order_future(symbol,amount,offset_flag,order_type,limit_price=None)

- 🔧作用：

下单函数，根据手数下单购买期货合约

- 📚参数说明：

symbol：合约代码，str
amount：委托数量（手），float
offset_flag：开平仓标识，str，'open'为开仓，'close'为平仓
order_type：多空仓标识，str，'long'为多仓，'short'为空仓
limit_price：限定价格，float，默认为None，表示市价即时单，否则委托单变为限价即时单

- 📝示例：

#初始化账户  
def init(context):  
    set_subportfolios([{'type':'FUTURE','cash':10000000}])
    #设定期货品种代码  
    context.symbol = 'RB1812'  

def handle_bar(context,bar_dict):  
    #下单10手螺纹钢1812合约，开多仓
    order_future(context.symbol,10,"open","long",limit_price=None)
​

##### 下单函数，平今仓单：order_close_today

- 👑调用方法：
order_close_today(symbol,amount,order_type,limit_price=None)

- 🔧作用：

平今仓单，仅仅能够平掉今天新开的仓位

- 📚参数说明：

symbol：合约代码，str
amount：委托数量（手），float
order_type：多空仓标识，str，'long'为多仓，'short'为空仓
limit_price：限定价格，float，默认为None，表示市价即时单，否则委托单变为限价即时单

- 📝示例：

#初始化账户  
def init(context):  
    set_subportfolios([{'type':'FUTURE','cash':10000000}])
    #设定期货品种代码  
    context.symbol=    'RB1812'  

def handle_bar(context,bar_dict):  
    #下单10手螺纹钢1812合约，开多仓
    order_future(context.symbol,10,"open","long")
    #平今仓5手螺纹钢1812合约
    order_close_today(context.symbol, 5,'long',limit_price=None)
​

#### 期权

##### 下单函数，根据数量下单：order_option

- 👑调用方法：
order_option(order_book_id, amount, side, position_effect, price=None)

- 🔧作用：

期权下单函数

- 📚参数说明：

order_book_id：期权代码，str
amount：委托数量（手），float
side：方向，str，'buy'为多仓，'sell'为空仓
position_effect：开平仓，str，'open'为开仓，'close'为平仓
price：限定价格，float，默认为None，表示市价即时单，否则委托单变为限价即时单

- 📝示例：

def init(context):
    set_subportfolios([{'cash': 100000, 'type': 'option'}])
    set_option_commission(5)        # 默认也是5
    g.ins= '10001485.SH'            # 看跌，20181128行权价2.7
    g.day = 1

def handle_bar(context, bar_dict):
    if g.day == 1:
        order_option(g.ins, 10, 'buy', 'open')
    elif g.day == 2:
        order_option(g.ins, 10, 'sell', 'close')
    g.day += 1
​

#### 场外基金

##### 申购基金：order_fund

- 👑调用方法：
order_fund(order_book_id, value)

- 🔧作用：

在场外基金API中，用于申购基金

- 📚参数说明：

order_book_id：基金代码，str
value：下单金额，float

- ❗注意事项：

只支持金额下单
下单成功返回order_id，下单失败返回None

- 📝示例：

def init(context):
    # 设置3个子账户，股票，期货，场外基金初始资金都为100000
    set_subportfolios([{'cash': 100000, 'type': 'fund'}, {'cash': 100000, 'type': 'future'}, {'cash': 100000, 'type': 'stock'}])
    context.ins = '000717.OF'

def handle_bar(context, bar_dict):
    order_id = order_fund(context.ins, 1000)
    log.info('申购', order_id)
​

##### 赎回基金：redeem_fund

- 👑调用方法：
redeem_fund(order_book_id, amount)

- 🔧作用：

在场外基金API中，用于赎回基金

- 📚参数说明：

order_book_id：基金代码，str
amount：下单份额，float

- ❗注意事项：

只支持份额下单
下单成功返回order_id，下单失败返回None

- 📝示例：

def init(context):
    # 设置3个子账户，股票，期货，场外基金初始资金都为100000
    set_subportfolios([{'cash': 100000, 'type': 'fund'}, {'cash': 100000, 'type': 'future'}, {'cash': 100000, 'type': 'stock'}])
    context.ins = '000717.OF'

def handle_bar(context, bar_dict):
    order_id = order_fund(context.ins, 1000)
    log.info('申购', order_id)
    order_id = redeem_fund(context.ins, 500)
    log.info('赎回', order_id)
​

### 枚举常量

#### ORDER_STATUS - 委托状态

| 枚举值 | 含义 |
| --- | --- |
| PENDING_NEW | 创建中 |
| ACTIVE | 未成交 |
| FILLED | 已成交 |
| REJECTED | 废单 |
| PENDING_CANCEL | 取消中 |
| CANCELLED | 已取消 |

### 重要对象

#### context账户对象

- 🔧作用：

全局对象，存储策略信息(context.run_info),账户持仓数据(context.portfolio)，也可用于储存自定义全局变量。仅在策略框架内可用

- ⛺数据结构(思维导图可使用鼠标滚轮放大、缩小，拖动操作)

- ❗注意事项：

自定义的全局变量尽可能存在 g中而不是 context,避免系统变量被覆盖

- 📝示例：

```
def init(context):
    context.fired=True
    log.info(context.run_info)
    log.info(context.portfolio)
    log.info(context.fired)
  
def handle_bar(context,bar_dict):
    if context.fired:
        odr_id = order('000001.SZ',100)
        context.fired = False
        log.info(context.run_info)
        log.info(context.portfolio)
        log.info(context.fired)
  
        log.info(context.portfolio.positions) #输出看起来像个列表,实际类似于字典
        log.info(context.portfolio.stock_account.positions)
  
        log.info(context.portfolio.positions['000001.SZ'])
        log.info(context.portfolio.stock_account.positions['000001.SZ'])
​
```

#### bar行情数据：bar_dict数据对象

- 🔧作用：

全局对象，用于储存当前时间的bar行情数据。仅在策略框架内可用

- ⛺数据结构(思维导图可使用鼠标滚轮放大、缩小，拖动操作) 日频:

- ❗注意事项：

使用股票API时，无需订阅
使用期货API时，需要使用 subscribe函数订阅

- 📝示例：

```
span
​
```

#### 当前bar行情数据：get_current

- 🔧作用：

- 获取当前bar的行情数据。仅在策略框架内可用。

- ❗注意事项：

- 在研究环境，使用get_current仅暂时与get_last_tick效果等同，并报错WARN提示替换。将下一版本彻底删除研究环境的get_current，请注意替换。

- 📝示例：

```
def handle_bar(context,bar_dict):
    log.info(get_current(['300033.SZ','600000.SH']))
​
```

#### 订单对象：order

- 🔧作用：

on_order函数推送,或使用get_order/get_orders/get_open_orders函数查询。仅在策略框架内可用

- ⛺数据结构(思维导图可使用鼠标滚轮放大、缩小，拖动操作) 日频:

- ❗注意事项：

可结合委托数量、成交数量、委托状态来判断区分未成交、部分成交、全撤、部成部撤的状态

- 📝示例：

```
def init(context):
    g.fired = True

def handle_bar(context,bar_dict):
    if g.fired:
        odr_id = order('000001.SZ',100)
        print(get_order(odr_id))
        g.fired=False

def on_order(context,odr):
    print(odr)
​
```

#### 成交对象：trade

- 🔧作用：

on_trade函数推送,或使用get_tradelogs函数查询。仅在策略框架内可用

- ⛺数据结构(思维导图可使用鼠标滚轮放大、缩小，拖动操作) 日频:

- ❗注意事项：

有成交时就会推送，不代表订单完全成交

- 📝示例：

```
def init(context):
    g.fired = True

def handle_bar(context,bar_dict):
    if g.fired:
        odr_id = order('000001.SZ',100)
        print(get_tradelogs())
        g.fired=False

def on_trade(context,trade):
    print(trade)
​
```

#### 全局变量对象：g

- 🔧作用：

全局对象，用于储存全局变量。仅在策略框架内可用

- ❗注意事项：

自定义的全局变量尽可能存在 g中而不是 context,避免系统变量被覆盖

- 📝示例：

def init(context):   
    #设置要交易的股票 
    g.contract = '300033.SZ'

def handle_bar(context, bar_dict):
    order(g.contract, 1000)
​

### 辅助函数

#### 日志函数：log

- 👑调用方法：

log.info(content)
log.warn(content)
log.error(content)
​

- 📚参数说明：

content：需要打印输出的日志内容，可以是字符串，也可以是某个对象

- 🔧作用：

log.info，log.warn，log.error是三种不同级别的打印函数,级别排序(先后)：error>warn>info

- ❗注意事项：

log.error是一个打印输出结果函数,当该函数执行后,整个策略会终止回测运行
需要将日志另存为文件持久化的话可以通过set_log_level函数进行设置
研究环境中同样可以使用

- 📝示例：

def init(context):
    pass

def handle_bar(context,bar_dict):
    # 获得当前Bar时间
    time =get_datetime()
    log.info('目前Bar时间:'+str(time))
​

#### 画图函数：record

- 👑调用方法：

record(**kwargs)
​

- 📚参数说明：

可变参数：key为曲线名称，value为当前日期下曲线对应的值

- 🔧作用：

画图函数，根据策略需求，自定义画图

- ❗注意事项：

该函数可以画出多条key线图走势，也可以是一条

- 📝示例：

#画出平安银行的5.10.20日均线走势图.
def init(context):
    pass

def handle_bar(context,bar_dict):
    value = history('000001.SZ', ['close'], 20, '1d', True, fq='pre')
    MA5=value['close'].iloc[-5:].mean()
    MA10=value['close'].iloc[-10:].mean()
    MA20=value['close'].iloc[-20:].mean()
    record(MA5=MA5, MA10=MA10,MA20=MA20)
​

#### 性能分析函数：enable_profile

- 👑调用方法：

enable_profile(func_list)
​

- 📚参数说明：

func_list：所需分析函数的名称,一般根据实际需求填写需要分析的函数名,不填默认分析所有函数

- 🔧作用：

性能分析函数,获取策略中各个函数的运行时间

- ❗注意事项：

该函数在策略框架函数之外执行
性能分析结果再日志的最后部分显示
func_list参数如果不填写，则默认为分析所有函数

- 📝示例：

```
#将初始双均线策略进行函数性能分析.
#初始化账户
def init(context):
    context.security = '600519.SH'

def handle_bar(context,bar_dict):
    close = history(context.security, ['close'], 20, '1d')
    MA5 = close.values[-5:].mean()
    MA20 = close.values.mean()
    if MA5 > MA20:
        order_target_percent(context.security,1)
    if MA5 < MA20:
        order_target(context.security,0)

enable_profile()
​
```

## 工具函数

### 股票代码格式转换：normalize_symbol

- 👑调用方法：

normalize_symbol(str,type)
​

- 📚参数说明：

str：股票、基金代码的字符串格式
type：转换代码类型，'stock'代表股票,'ota'代表基金,默认为 'stock'

- 🔧作用：

代码转换函数，可以将其他形式的股票（基金）代码转换为SuperMind的股票（基金）代码形式

- ❗注意事项：

其他形式的股票、基金代码,其格式必须是字符串格式,例如'300033'
不能输入文字，必须是代码，可以是股票也可以是基金
研究环境中同样可以使用

- 📝示例：

```
#将初始双均线策略进行函数性能分析.
#初始化账户
def init(context):
    context.security = '300033'

def handle_bar(context,bar_dict):
    log.info(normalize_symbol(context.security,'stock'))
​
```

### 保存文件函数：write_file

- 👑调用方法：

write_file(path, content, append=False)
​

- 📚参数说明：

path：str，相对路径，研究环境路径，例如，'test.txt'代表在研究环境根目录中创建一个test.txt文件，并写入数据
content：需要保存的内容，str格式或者unicode格式, 如果是unicode, 则会使用UTF-8编码再存储.可以是二进制内容.str格式即为字符串格式,例如:'明天会下雨'
append：bool,是否是追加模式，当路径不变时，新的内容是否覆盖旧的内容，默认为False

append=True:该文件下再次保存内容是会保留之前的旧内容
append=False:该文件下再次保存内容是会覆盖之前的旧内容

- 🔧作用：

保存文件函数，将内容保存到研究模块目录中

- ❗注意事项：

该函数保存的内容的格式必须转化成str格式或者unicode格式
研究环境中同样可以使用

- 📝示例：

#用智能选股选出沪深300股票出来后，以文件形式保存到我的研究文件中.
def init(context):
    get_iwencai('沪深300','stocks_list')

def handle_bar(context,bar_dict):   
    write_file('test.txt', str(context.stocks_list))
​

### 读取文件函数：read_file

- 👑调用方法：

read_file(path)
​

- 📚参数说明：

path：str，相对路径，研究环境文件路径，例如，'test.txt'代表在研究环境根目录中名为test.txt文件

- 🔧作用：

读取文件函数，读取研究环境中的文件

- ❗注意事项：

文件保存在文件夹中，则path的格式必须是'文件夹名/文件名'
文件保存在根目录下，则path格式为:'文件名'
研究环境中同样可以使用

- 📝示例：

```
def init(context):
    get_iwencai('沪深300','stocks_list')

def handle_bar(context,bar_dict):   
    write_file('test.txt', str(context.stocks_list))
    data = read_file('test.txt')
    log.info(data)
​
```

### 查询研究环境指定路径下的文件：list_file

- 👑调用方法：

list_file(path, isfile=None, isdir=None, abspath=True)
​

- 📚参数说明：

path：str，研究环境文件路径，例如，'test'代表在研究环境根目录中名为test的文件夹
isfile: bool，是否返回文件，默认为None
isdir：bool，是否返回文件夹，默认为None
abspath：bool，是否返回绝对路径，默认为True

- 🔧作用：

查询研究环境指定路径下的文件

- ❗注意事项：

isfile和isdir都为None时，代表即返回文件，又返回文件夹
研究环境中同样可以使用

- 📝示例：

```
def init(context):
    print(list_file(''))

def handle_bar(context,bar_dict):   
    pass
​
```

### 复制/剪贴文件或文件夹：copy_file

- 👑调用方法：

copy_file(src, dst, move=False)
​

- 📚参数说明：

src：str，需要操作的文件或文件夹的路径
dst: str，目标路径(研究环境),例如，'test'代表在研究环境根目录中名为test的文件夹
move：bool，是否剪贴，默认为False

- 🔧作用：

复制/剪贴文件或文件夹

- ❗注意事项：

迁移单个文件时，设置目标路径时也需要具体到文件名
可以利用此函数新建文件夹：copy_file(None,'new_folder')，代表在根目录下新建名为‘new_folder’的文件夹
研究环境中同样可以使用

- 📝示例：

```
def init(context):
    write_file('test.txt','123')
    copy_file(None,'new_folder')
    copy_file('test.txt','new_folder/abc.txt',move=True)

def handle_bar(context,bar_dict):   
    pass
​
```

### 删除文件或文件夹：remove_file

- 👑调用方法：

remove_file(path, trash=True)
​

- 📚参数说明：

path：str，需要删除文件/文件夹的路径
trash: bool，是否移入回收站，默认为True，为False时意味着彻底删除

- 🔧作用：

删除文件或文件夹

- ❗注意事项：

trash=False时意味着彻底删除文件，不可恢复
研究环境中同样可以使用

- 📝示例：

```
def init(context):
    write_file('test.txt','123')
    remove_file('test.txt')

def handle_bar(context,bar_dict):   
    pass
​
```

### 消息推送函数：notify_push

- 👑调用方法：

notify_push(
    content, 
    channel='wxpusher', 
    subject='SuperMind消息提醒', 
    email_list=None, 
    uids=None, 
    topic_ids=None, 
    group_id=None,
    url=None,
    payload=None,
)
​

- 📚参数说明：

content：需要推送的消息文本
channel: 目前支持微信推送、webhook，参数值分别为 "wxpusher"、"webhook"
subject: 消息主题
uids: list，channel为 wxpusher需要填写，用户的UID，关注公众号，点击“我的－我的UID”获取用户UID信息
url: str，channel为 webhook需要填写，webhook地址
payload: dict，channel为 webhook需要填写，消息格式，如钉钉的消息格式为 {"msgtype": "text", "text": {"content": "$content"}}，其中 $content会被替换为 content参数传入的值

- 🔧作用：

消息推送函数，在研究环境、策略编辑等模块均可使用

- ❗注意事项：

channel='wxpusher'时，需要先关注公众号：

webhook教程见：模拟仿真 (10jqka.com.cn)

- 📝示例：

```
try:
    raise
except:
    # 微信推送
    notify_push(
        '程序报错', 
        channel='wxpusher', 
        subject='SuperMind消息提醒', 
        uids='XXXXXX',
    )
    # 钉钉webhook推送
    notify_push(
        '程序报错', 
        channel='webhook',   
        url='XXXXXX',
        payload={"msgtype": "text", "text": {"content": "$content"}},
    )
​
```

### 自选板块：custom_sector

- 👑调用方法：

custom_sector(name=None, action='query', symbol=None, rename=None)
​

- 📚参数说明：

name：str，板块名称
action: str，insert - 新建name的板块，update - 更新指定板块的股票列表或重命名，append - 在指定板块中新增股票，pop - 移除指定板块内的个别股票，remove - 移除指定板块
symbol：list，股票列表
rename: str，重命名板块名称

- 🔧作用：

读取或修改自选板块

- 📝示例：

```
custom_sector() # 返回所有板块的dataframe

custom_sector('板块1') # 返回 板块1 的属性和股票

custom_sector('板块1', 'insert', ['000001.SZ']) # 新建板块1的股票列表

custom_sector('板块1', 'update', ['000001.SZ'], '新名字') # 更新板块1的股票列表或名字

custom_sector('板块1', 'append', ['000001.SZ']) # 增加板块1的股票列表

custom_sector('板块1', 'pop', ['000001.SZ']) # 移除板块1的股票

custom_sector('板块1', 'remove') # 删除板块1
​
```

## 通用数据接口

### 行情资金数据

#### 行情数据：get_price

- 👑调用方法：

```
get_price(
    securities,
    start_date=None,
    end_date='20180101',
    fre_step='1d',
    fields=None,
    skip_paused=False,
    fq='pre',
    bar_count=0,
    is_panel=False,
)
​
```

- 📚参数说明：

securities：str或list, 标的代码

start_date：str,int,float,datetime-like，起始时间，不能和bar_count共存

end_date：str,int,float,datetime-like，结束时间

fre_step：str，时间步长，支持分钟、日

fre_step = 'xd'：x为正整数，代表x天，例如'1d'代表1天
fre_step = 'xm'：x为正整数，代表x分钟，例如'1m'代表1分钟

fields：list，需要获取的字段，可参考

日频：股票日行情数据(A股)
分钟：股票分钟行情数据(A股)
当步长不为'1m'或'1d'时，fields仅支持'open', 'close', 'high', 'low', 'volume', 'turnover'这几个字 段

skip_paused：bool，是否跳过停牌，默认为不跳过

fq：str，复权模式

fq=None: 不复权
fq='post': 后复权
fq='pre': 动态前复权

bar_count：int，历史长度，bar_count不为0时 start_date必须为 None

is_panel：bool，返回数据格式，默认为False

当取多个标的行情数据时，is_panel=False时，返回key为股票代码，value为dataframe的字典
当取多个标的行情数据时，is_panel=True时，返回panel格式数据
当取单个标的行情数据时，返回dataframe

- 🔧作用：

获取多只证券多属性历史行情数据

- ❗注意事项：

该函数支持获取实时行情
该函数还支持查询场内基金、指数、可转债等标的的行情数据，支持字段可查询SuperMind数据平台
返回panel格式数据时，可以用to_frame()方法将数据转换为一个具有mutilindex的二维dataframe
暂不支持获取CSI结尾指数的历史分钟行情数据

- 📝示例：

```
# 获取平安银行股票, 万科A, 贵州茅台2023年2月1日前3天的收盘价、最高价、最低价
value = get_price(['000001.SZ','000002.SZ','600519.SH'], None, '20230201', '1d', ['close', 'high', 'low'], True, None, 3, is_panel=1)
# 打印收盘价数据
print(value['close'])
​
```

- 返回格式：

```
000001.SZ  000002.SZ  600519.SH
2023-01-30      15.15      18.09    1888.00
2023-01-31      14.99      18.29    1845.76
2023-02-01      14.70      18.19    1844.97
​
```

#### 当前bar行情数据：get_current

- 👑调用方法：

```
get_current(securities)
​
```

- 📚参数说明：

securities：str或list, 标的代码

- 🔧作用：

获取获取多只证券当前bar的行情数据。仅在策略框架内可用。

- ❗注意事项：

在研究环境，使用get_current仅暂时与get_last_tick效果等同，并报错WARN提示替换。将在下一版本废弃研究环境中的get_current，请注意替换。
返回数据结构，可参考bar_dict数据对象

📝示例：

```
log.info(get_current(['300033.SZ','600000.SH']))
​
```

#### 开盘竞价成交信息：get_call_auction

- 👑调用方法：

get_call_auction(symbol, dt=None)
​

- 📚参数说明：

symbol：str, 标的代码
date：str,int,float,datetime-like，结束时间

- 📝示例：

get_call_auction(['000001.SZ'],'20230613')
​

- 返回数据：

price   turnover
symbol   
000001.SZ  11.76  3988992.0
​

#### 期货行情数据：get_price_future

- 👑调用方法：
get_price_future(
    symbol_list,
    start_date,
    end_date,
    fre_step,
    fields=None,
    bar_count=0,
    is_panel=0,
)
​

- 📚参数说明：

symbol_list：str或list, 标的代码

start_date：str,int,float,datetime-like，起始时间，不能和bar_count共存

end_date：str,int,float,datetime-like，结束时间

fre_step：str，时间步长，支持分钟、日

fre_step = 'xd'：x为正整数，代表x天，例如'1d'代表1天
fre_step = 'xm'：x为正整数，代表x分钟，例如'1m'代表1分钟

fields：list，需要获取的字段，可参考

日频：期货日行情数据(A股)
分钟：期货分钟行情数据(A股)
当步长不为'1m'或'1d'时，fields仅支持'open', 'close', 'high', 'low', 'volume', 'turnover'这几个字段

bar_count：int，历史长度，bar_count不为0时 start_date必须为 None

is_panel：bool，返回数据格式，默认为False

当取多个标的行情数据时，is_panel=False时，返回key为股票代码，value为dataframe的字典
当取多个标的行情数据时，is_panel=True时，返回panel格式数据
当取单个标的行情数据时，返回dataframe

- 🔧作用：

获取多只期货合约多属性历史行情数据

- ❗注意事项：

该函数支持获取实时行情
返回panel格式数据时，可以用to_frame()方法将数据转换为一个具有mutilindex的二维dataframe

- 📝示例：
# 获取IC2304、IF2304两个标的在2023年4月6日前3天的收盘价、最高价、最低价
value = get_price_future(
    symbol_list = ['IC2304','IF2304'],
    start_date = None,
    end_date = '20230406',
    fre_step = '1d',
    fields=['close', 'high', 'low'],
    bar_count = 3,
    is_panel = 1
)
# 打印收盘价数据
print(value['close'])
​

- 返回数据：
IC2304  IF2304
2023-04-03  6406.0  4091.2
2023-04-04  6415.0  4111.8
2023-04-06  6411.4  4098.0
​

#### 蜡烛图数据：get_candle_stick

- 👑调用方法：
get_candle_stick(
    securities,
    end_date='20180101',
    fre_step='1d',
    fields=None,
    skip_paused=False,
    fq='pre',
    bar_count=0,
    is_panel=False,
)
​

- 📚参数说明：

securities：str或list, 标的代码

end_date：str,int,float,datetime-like，结束时间

fre_step：str，时间步长，支持分钟、日、周、月、年

分钟：支持'1m','5m','15m','30m','60m'
日频：支持自定义天数，'nd'，例如'2d'代表2天
周：'week'
月：'month'
年：'year'

fields：list，需要获取的字段，仅支持'open','high','low','close','volume','turnover'

skip_paused：bool，是否跳过停牌，默认为不跳过

fq：str，复权模式

fq=None: 不复权
fq='post': 后复权
fq='pre': 动态前复权

bar_count：int，历史长度，bar_count不为0时 start_date必须为 None

is_panel：bool，返回数据格式，默认为False

当取多个标的行情数据时，is_panel=False时，返回key为股票代码，value为dataframe的字典
当取多个标的行情数据时，is_panel=True时，返回panel格式数据
当取单个标的行情数据时，返回dataframe

- 🔧作用：

获取股票、债券、基金的历史蜡烛图数据

- ❗注意事项：

返回panel格式数据时，可以用to_frame()方法将数据转换为一个具有mutilindex的二维dataframe

- 📝示例：
# 获取600519.SH、000002.SZ两个标的在2023年8月1日前3个月线的行情数据
data = get_candle_stick(
    ['600519.SH','000002.SZ'], 
    end_date='20230801',
    fre_step='month',
    fields=['open', 'close', 'high', 'low', 'volume'],
    skip_paused=False,
    fq='pre',
    bar_count=3,
    is_panel=0
)
# 打印收盘价数据
print(value['close'])
​

- 返回数据示例：

#### 获取实时行情快照数据：get_last_tick

- 👑调用方法：

get_last_tick(securities, fields)
​

- 📚参数说明：

securities：str或list, 标的代码
fields：list，需要获取的字段，可参考实时行情快照

- 🔧作用：

获取多只证券的实时行情快照数据

- ❗注意事项：

- 获取当日数据时，响应时间超过六秒会报超时错误

- 📝示例：

from mindgo_api import *
# 获取平安银行的最新价
data = get_last_tick('000001.SZ',['current'])
print(data)
​

#### 获取历史行情快照数据：get_tick

- 👑调用方法：

get_tick(securities, start_date, end_date, fields)
​

- 📚参数说明：

securities：str或list, 标的代码
start_date：str,int,float,datetime-like，起始时间
end_date：str,int,float,datetime-like，结束时间
fields：list，需要获取的字段，可参考历史行情快照

- 🔧作用：

获取多只证券的历史行情快照数据

- ❗注意事项：

该函数也支持获取日内快照数据
获取当日数据时，响应时间超过六秒会报超时错误

- 📝示例：

# 获取平安银行的2023年8月1日9点23分至9点30分的成交价
data = get_tick('000001.SZ','20230801 09:23','20230801 09:30',['current'])
print(data)
​

#### 统计涨跌区间个股数量：get_stats

- 👑调用方法：

get_stats(date=None)
​

- 📚参数说明：

date：str，查询日期，默认当日

- 🔧作用：

获取每日/实时行情中各个涨跌区间的个股数量

- ❗注意事项：

一共有21个涨跌幅区间： (无穷小,-9)，[-9,-8)...[-1,0),[0],(0,1]...(9,无穷大)

- 📝示例：

# 获取2023年8月10日全市场股票的涨跌幅区间
data = get_stats('20230810')
print(data)
​

#### 压力支撑位数据：get_resistance_support

- 👑调用方法：

get_resistance_support(
    symbol_list,
    start_date=None,
    end_date='20180101',
    fre_step='1d',
    fields=[],
    bar_count=0,
    is_panel=0,
)
​

- 📚参数说明：

symbol_list：str或list, 标的代码

start_date：str,int,float,datetime-like，起始时间，不能和bar_count共存

end_date：str,int,float,datetime-like，结束时间

fre_step：str，时间步长，支持'1d','30m','5m'三种步长

fields：list，需要获取的字段

'resistance_line'：价格压力位(元)
'support_line'：价格支撑位(元)

bar_count：int，历史长度，bar_count不为0时 start_date必须为 None

is_panel：bool，返回数据格式，默认为False

当取多个标的行情数据时，is_panel=False时，返回key为股票代码，value为dataframe的字典
当取多个标的行情数据时，is_panel=True时，返回panel格式数据
当取单个标的行情数据时，返回dataframe

- 🔧作用：

获取多只证券股价压力位、支撑位数据

- ❗注意事项：

返回panel格式数据时，可以用to_frame()方法将数据转换为一个具有mutilindex的二维dataframe

- 📝示例：

# 000001.SZ在2023年8月1日至2023年8月10日阻力线的日数据，字典形式输出
data = get_resistance_support(
    symbol_list='000001.SZ',
    start_date='20230801',
    end_date='20230810',
    fre_step='1d',
    fields=['resistance_line'],
    bar_count=None,
    is_panel=0
)
print(data)
​

#### 获取基金净值数据：get_extras

- 👑调用方法：
get_extras(
    security_list,
    start_date=None,
    end_date='20180101',
    fields=None,
    count=None,
    is_panel=False,
)
​

- 📚参数说明：

security_list：list, 标的代码

start_date：str,int,float,datetime-like，起始时间，不能和bar_count共存

end_date：str,int,float,datetime-like，结束时间

fre_step：str，时间步长，支持'1d','30m','5m'三种步长

fields：list，需要获取的字段

'unit_net_value'：单位净值(元/份)
'acc_net_value'：累计净值(元/份)
'pre_net_value'：复权净值(元/份)

count：int，历史长度，count不为 None时 start_date必须为 None

is_panel：bool，返回数据格式，默认为False

当取多个标的行情数据时，is_panel=False时，返回key为股票代码，value为dataframe的字典
当取多个标的行情数据时，is_panel=True时，返回panel格式数据

- 🔧作用：

获取多只基金的净值数据

- ❗注意事项：

返回panel格式数据时，可以用to_frame()方法将数据转换为一个具有mutilindex的二维dataframe

- 📝示例：
# 沪深300ETF、中证500ETF在2023年8月1日至2023年8月10日单位净值、累计净值、复权净值
data = get_extras(['510300.OF', '510500.OF'], '20230801', '20230805', ['unit_net_value','acc_net_value','pre_net_value'])
print(data)
​

#### 融资融券数据：get_mtss

- 👑调用方法：
get_mtss(
    security_list,
    start_date=None,
    end_date='20180101',
    fields=None,
    count=None,
    is_panel=False,
)
​

- 📚参数说明：

security_list：list, 标的代码

start_date：str,int,float,datetime-like，起始时间，不能和bar_count共存

end_date：str,int,float,datetime-like，结束时间

fields：list，需要获取的字段

'fin_value'：融资余额(元)
'fin_buy_value'：融资买入额(元)
'fin_refund_value'：融资偿还额(元)
'sec_value'：融券余额(元)
'sec_sell_value'：融券卖出额(元)
'sec_refund_value'：融券偿还额(元)
'fin_sec_value'：融资融券余额(元)

count：int，历史长度，count不为 None时 start_date必须为 None

is_panel：bool，返回数据格式，默认为False

当取多个标的行情数据时，is_panel=False时，返回key为股票代码，value为dataframe的字典
当取多个标的行情数据时，is_panel=True时，返回panel格式数据

- 🔧作用：

获取股票的历史融资融券数据

- ❗注意事项：

返回panel格式数据时，可以用to_frame()方法将数据转换为一个具有mutilindex的二维dataframe
仅支持日频

- 📝示例：
#获取平安银行2023年8月1日过去20天的融资余额与融券余额数据
data =get_mtss(['000001.SZ'], None, '20230801', ['fin_value', 'sec_value'], 20, is_panel=0)
print(data)
​

#### 获取历史资金数据：get_money_flow_step

- 👑调用方法：
get_money_flow_step(
    security_list,
    start_date=None,
    end_date='20180101',
    fre_step='1d',
    fields=None,
    count=None,
    is_panel=False,
)
​

- 📚参数说明：

security_list：list, 标的代码

start_date：str,int,float,datetime-like，起始时间，不能和bar_count共存

end_date：str,int,float,datetime-like，结束时间

fre_step：str，时间步长，支持'1d','30m','5m'三种步长

fields：list，需要获取的字段，可参考资金流向数据

count：int，历史长度，count不为 None时 start_date必须为 None

is_panel：bool，返回数据格式，默认为False

当取多个标的行情数据时，is_panel=False时，返回key为股票代码，value为dataframe的字典
当取多个标的行情数据时，is_panel=True时，返回panel格式数据

- 🔧作用：

获取股票的历史资金流向数据

- ❗注意事项：

返回panel格式数据时，可以用to_frame()方法将数据转换为一个具有mutilindex的二维dataframe

大单、中单、小单的标准如下：

A.上证A股、深证主板大单标准：

           类型       股数                      金额                 占流通盘比
           小单       1万股以下         或     5万元以下
           中单       1万股到6万股       或     5万元—30万元
           大单       6万股到20万股      或     30万元—100万元          或    0.1%
           特大单      20万股以上        或     100万元以上
    B.中小板、创业板大单标准：

            类型       金额
            小单       5万元以下
            中单       5万元—20万元(包括5万，不包括20万)
            大单       20万元—50万元(包括20万，不包括50万)
            特大单      50万元以上
​

- 📝示例：
#获取平安银行2023年8月1日至2023年8月10日的日频主动买入大单数据
data = get_money_flow_step(
    security_list=['000001.SZ'],
    start_date='20230801',
    end_date='20230810',
    fre_step='1d',
    fields=['act_buy_xl'],
    count=None,
    is_panel=0
)
print(data)
​

### 证券信息数据

#### 获取单只证券的基本信息：get_security_info

- 👑调用方法：
get_security_info(symbol)

- 📚参数说明：

symbol：str，股票、期货、基金、指数等证券标的对应的同花顺代码

- 🔧作用：

获取单只证券的基本信息

- ❗注意事项：

symbol需要满足同花顺的格式，否则无法正常取到数据
该函数获取的标的简称在回测中不可用于判断是否为ST股

- 📝示例：

data = get_security_info('000001.SZ')
print(data)
​

#### 获取所有证券信息：get_all_securities

- 👑调用方法：
get_all_securities(ty=None, date=None)

- 📚参数说明：

ty：str，证券类型，默认取所有证券类型

ty='stock'：A股
ty='hstock'：港股
ty='ustock'：美股
ty='index'：指数
ty='etf'：ETF基金
ty='lof'：LOF基金
ty='fja'：分级A基金
ty='fjb'：分级B基金
ty='qdii'：qdii基金
ty='ota'：场外基金
ty='fund'：资产支持证券
ty='futures'：金融期货
ty='commodity_futures'：商品期货
ty='bond_futures'：国债期货
ty='option'：ETF期权
ty='cbond'：A股可转债
ty='forex'：外汇（中国银行双向宝）合约
ty='metal'：T+D延期交收合约

date: str，查询日期，回测时默认为当前回测时间的前一交易日，研究环境中默认为前一交易日

- 🔧作用：

获取单只证券的基本信息

- ❗注意事项：

该函数获取的标的简称在回测中不可用于判断是否为ST股

- 📝示例：

#查询2023年8月1日处于上市状态的沪京深股票信息
data = get_all_securities('stock','20230801')
print(data)
​

#### 获取期货期权品种相关信息：get_futures_info

- 👑调用方法：
get_futures_info(symbol, date=None)

- 📚参数说明：

symbol：str，期货品种类型
date: str，查询日期，回测时默认为当前回测时间的前一交易日，研究环境中默认为前一交易日

- 🔧作用：

获取期货品种相关信息

- 📝示例：

#查询螺纹钢期货的2023年8月1日的品种信息
data = get_futures_info('RB','20230801')
print(data)
​

#### 获取主力合约代码：get_futures_dominate

- 👑调用方法：
get_futures_dominate(symbol, date=None, seq=0)

- 📚参数说明：

symbol: str，期货合约品种，例如沪深300股指期货为'IF'
date: str，查询日期，回测时默认为当前回测时间的前一交易日，研究环境中默认为前一交易日
seq: int，默认为0，表示主力合约，为1表示次主力合约，依次按序列推，超出序列返回None

- 🔧作用：

获取某个日期的某个品种的主力合约代码，以主力持仓来划分，该品种持仓量连续三日最大且为远
期合约时，主力合约会进行切换

- 📝示例：

#查询2023年8月1日的螺纹钢期货主力合约
data =get_futures_dominate('RB','20230801')
print(data)
​

#### 获取指定品种所有可交易的合约：get_future_code

- 👑调用方法：
get_futures_dominate(underlying_symbol, date=None)

- 📚参数说明：

underlying_symbol: str，期货合约品种，例如沪深300股指期货为'IF'
date: str，查询日期，回测时默认为当前回测时间的前一交易日，研究环境中默认为前一交易日

- 🔧作用：

获取当前期货品种所有可交易的期货合约

- 📝示例：

#查询2023年8月1日可交易的螺纹钢期货合约
future_code_all=get_future_code('RB','20230801)
print(future_code_all)
​

#### 获取可交易的期权合约列表：get_option_code

- 👑调用方法：
get_option_code(date=None)

- 📚参数说明：

date: str，查询日期，回测时默认为当前回测时间的前一交易日，研究环境中默认为前一交易日

- 🔧作用：

获取当前所有可交易的沪深交易所ETF期权合约

- 📝示例：

#查询2023年8月1日可交易的螺纹钢期货合约
options_all = get_option_code('20230801')
print(options_all)
​

#### 获取指数成份股：get_index_stocks

- 👑调用方法：
get_index_stocks(symbol, date=None)

- 📚参数说明：

symbol: str，指数代码
date: str，查询日期，回测时默认为当前回测时间的前一交易日，研究环境中默认为前一交易日

- 🔧作用：

获取指数对应的成分股股票代码列表

- ❗注意事项：

该函数若在模拟交易的init函数中使用,则必须填写date参数

- 📝示例：
#查询2023年8月1日上证50成分股
stock_list= get_index_stocks('000016.SH','20230801')
print(stock_list)
​

#### 获取指数成份股权重：get_index_weight

- 👑调用方法：
get_index_weight(symbol, date=None)

- 📚参数说明：

symbol: str，指数代码
date: str，查询日期，回测时默认为当前回测时间的前一交易日，研究环境中默认为前一交易日

- 🔧作用：

获取指数对应的成分股权重数据

- ❗注意事项：

部分等权指数会返回空的dataframe，例如同花顺指数
该函数若在模拟交易的init函数中使用,则必须填写date参数

- 📝示例：
#查询2023年8月1日上证50成分股权重
weight = get_index_weight('000016.SH','20230801')
print(weight)
​

#### 获取指数列表：get_index_list

- 👑调用方法：
get_index_list(suffix, date=None)

- 📚参数说明：

suffix: str，指数代码后缀
date: str，查询日期，回测时默认为当前回测时间的前一交易日，研究环境中默认为前一交易日

- 🔧作用：

跟据指数代码后缀查询指数

- 📝示例：

#查询2023年8月1日后缀为'TI'的指数列表(同花顺指数)
index_list = get_index_list('TI','20230801')
print(index_list)
​

#### 获取行业成份股：get_industry_stocks

- 👑调用方法：
get_industry_stocks(symbol, date=None)

- 📚参数说明：

symbol: str，行业指数代码
date: str，查询日期，回测时默认为当前回测时间的前一交易日，研究环境中默认为前一交易日

- 🔧作用：

获取行业对应的成分股股票代码列表

- 📝示例：

#查询2023年8月1日中信二级行业-一般零售的成分股列表
index_list = get_industry_stocks('CI311000','20230801')
print(index_list)
​

#### 获取行业分类信息：get_industry_relate

- 👑调用方法：
get_industry_relate(date='now', types='industryid1', fields=None)

- 📚参数说明：

date: str，查询日期，默认为当前时间
types：行业分类类型，支持同花顺行业分类、申万行业分类、中信行业分类、证监会行业分类，可在SuperMind数据平台中查询
fields：字段名，可以参考行业分类信息字段

- 🔧作用：

获取A股行业分类信息，可查到行业分类及对应代码

- 📝示例：
#查询2023年8月1日中信二级行业分类信息
industry_info = get_industry_relate(date='20230801',types='ci_industryid2')
print(industry_info)
​

#### 获取股票所属行业数据：get_symbol_industry

- 👑调用方法：
get_symbol_industry(symbol, date=None)

- 📚参数说明：

symbol: str，股票代码
date: str，查询日期，默认为当前时间

- 🔧作用：

获取个股的行业分类信息，支持同花顺行业分类、申万行业分类、中信行业分类、证监会行业分类、标普行业分类

- 📝示例：
#查询300033.SZ(同花顺)在2023年8月1日的行业分类信息
industry_info = get_symbol_industry('300033.SZ',date='20230801')
print(industry_info)
​

#### 获取所有同花顺概念成分股：get_concept_stocks

- 👑调用方法：
get_concept_stocks(symbol, date=None)

- 📚参数说明：

symbol: str，概念代码或者概念指数代码
date: str，查询日期，回测时默认为当前回测时间的前一交易日，研究环境中默认为前一交易日

- 🔧作用：

获取概念下的成分股

- ❗注意事项：

通常在同花顺行情软件上能看到行情的都是概念指数，代码以TI结尾
概念不一定有对应的概念指数
概念指数的成分股也可以通过 get_index_stocks函数获取

- 📝示例：

#查询2023年8月1日ChatGPT概念的成分股
stock_list = get_concept_stocks('886031.TI',date='20230801')
print(stock_list)
​

#### 获取所有同花顺概念信息：get_concept_relate

- 👑调用方法：
get_concept_relate(date='now', levels=None, fields=None)

- 📚参数说明：

date: str，查询日期，默认为当前时间
levels: str或list，概念类型，默认取所有概念
fields: list，需要查询的字段，默认返回所有字段

- 🔧作用：

获取所有同花顺概念分类信息及对应的指数代码

- ❗注意事项：

通常在同花顺行情软件上能看到行情的都是概念指数，代码以TI结尾
概念不一定有对应的概念指数

- 📝示例：
#查询2023年8月1日所有同花顺概念信息
concept_info = get_concept_relate(date = '20230801')
print(concept_info)
​

#### 获取指定时间段交易日：get_trade_days

- 👑调用方法：
get_trade_days(start_date=None, end_date='20180101', count=None)

- 📚参数说明：

start_date: str,int,datetime_like，起始日期，默认为None
end_date: str,int,datetime_like，结束日期，默认为'20180101'
count: int，交易日数量

- 🔧作用：

获取沪深京交易所指定时间段交易日

- ❗注意事项：

当start_date、end_date全部不为None时，count参数不生效

- 📝示例：
#查询2023年1月1日至2023年8月1日之间的交易日
tdays_list = get_trade_days('20230101','20230801')
print(tdays_list)
​

#### 获取所有交易日：get_all_trade_days

- 👑调用方法：
get_all_trade_days()

- 🔧作用：

获取沪深京交易所所有交易日

- ❗注意事项：

该函数不需要填写参数

- 📝示例：
#查询所有交易日
tdays_list = get_all_trade_days()
print(tdays_list)
​

#### 获取因子数据：get_sfactor_data

- 👑调用方法：
get_sfactor_data(start_date, end_date, stocks, factor_names)

- 📚参数说明：

start_date: str,int,datetime_like，起始日期
end_date: str,int,datetime_like，结束日期
stocks：list，股票池
factor_names：list，因子池

技术指标类因子
财务指标类因子

- 🔧作用：

获取因子数据（已做数据处理：去极值、标准化）

- ❗注意事项：

此函数支持获取自定义因子

- 📝示例：

#获取300033.SZ（同花顺）和600519.SH（贵州茅台）2023年8月1日到2023年8月5日的macd因子数据
start_date = '20230801'
end_date = '20230805'
stocks=['600519.SH','300033.SZ']
factor_input = ['macd']
factor_info = get_sfactor_data(start_date, end_date, stocks, factor_input)
​

### 表数据

#### 表数据对象：query

- 👑调用方法：
query(table)

- 📚参数说明：

table:数据表对象，支持的数据可在SuperMind数据平台中查询

- 🔧作用：

构造query对象，传入需要取数的信息

- 🚀️使用方法：

仅取某字段：有时候不需要把整张表取出，仅仅想取表中的某几个字段

#只取concept_classification表的symbol、date、concept三个字段
q = query(
    concept_classification.symbol,#格式为：表名.字段
    concept_classification.date,
    concept_classification.concept
)
​

filter操作：设置条件，相当于SQL中的where方法

#只取concept_classification表的symbol、date、concept三个字段，并只取同花顺2023年2月1日之后的数据
q = query(
    concept_classification.symbol,#格式为：表名.字段
    concept_classification.date,
    concept_classification.concept
).filter(
    concept_classification.symbol=='300033.SZ',
    concept_classification.date>'20230201'
)
​
#只取concept_classification表的symbol、date、concept三个字段，并取同花顺、贵州茅台在2023年2月1日当天的数据
q = query(
    concept_classification.symbol,#格式为：表名.字段
    concept_classification.date,
    concept_classification.concept
).filter(
    concept_classification.symbol.in_(['300033.SZ','600519.SH']),
    concept_classification.date=='20230201'
)
​

limit操作：指定查询前n行数据

#只取concept_classification表的symbol、date、concept三个字段的前10行
q = query(
    concept_classification.symbol,#格式为：表名.字段
    concept_classification.date,
    concept_classification.concept
).limit(10)
​

order_by操作：指定一列数据进行排序

#只取concept_classification表的symbol、date、concept，并跟据date降序排列
q = query(
    concept_classification.symbol,#格式为：表名.字段
    concept_classification.date,
    concept_classification.concept
).order_by(
    concept_classification.date.desc()
)
​

- ❗注意事项：

order_by从大到小排序则使用：.desc(),从小到大排序则使用：.aes()
更多详细使用方法可以参考sqlalchemy官方文档
构造完query对象后需要用 run_query或者 get_fundamentals取数

#### 取表数据：run_query

- 👑调用方法：
run_query(query_object)

- 📚参数说明：

query_object:query对象，使用方法可参考query对象文档

- 🔧作用：

查询函数，可查询除财务数据表以外的所有数据表

- ❗注意事项：

财务数据表不支持使用此函数查询
支持的数据可在SuperMind数据平台中查询

- 📝示例：

```
#获取300033.SZ（同花顺）和600519.SH（贵州茅台）2023年2月1日的概念数据
data = run_query(
    query(
        concept_classification.symbol,#格式为：表名.字段
        concept_classification.date,
        concept_classification.concept
    ).filter(
        concept_classification.symbol.in_(['300033.SZ','600519.SH']),
        concept_classification.date=='20230201'
    )
)
​
```

#### 取财务表数据：get_fundamentals

- 👑调用方法：
get_fundamentals(query_object, date=None, statDate=None, latest=False)

- 📚参数说明：

query_object:query对象，使用方法可参考query对象文档

- 🔧作用：

查询函数，可查询财务数据表

- ❗注意事项：

此函数仅支持查询财务数据表
date和statDate参数传其中之一即可
date和statDate全为None时，date默认取当前时间的前一日
支持的数据可在SuperMind数据平台中查询

- 📝示例：

```
#查询2023年8月1日的总市值数据，并降序排列
data = get_fundamentals(
    query(
        valuation.symbol,
        valuation.market_cap
    ).order_by(
        valuation.market_cap.desc()
    ),
    date = '20230810'
)
print(data.head())
​
```

## 问财接口

### 问财接口使用前必读

问财选股接口因为他的便利和速度而广受喜欢。

然而问财的诞生之初是用于实时选股，而非回测。所以在回测的场景必然会存在一些问题。这些问题解决需要时间和精力，如果你发现问题记得及时反馈给supermind官方。我们会持续推动解决。

建议用问财来快速验证想法，然后自己用pyhton实现代码是比较好的方式。

query_iwencai 和 get_iwencai 的结果是不一样的，因为二者调用的服务是不一样的：query_iwencai，基于i问财智能投顾，主要用于实时选股，注意，目前iwencai分为2套，API返回结果与旧版是一致的；get_iwencai基于BackTest 量化策略平台 (10jqka.com.cn)，主要用于历史回测，get_iwencai 为了避免一些未来函数，会再回测环境对某些语句不可用，会出现iwencai初始化失败的提示。

自然语言解析较为复杂，最好先到对应的问财网站对问句进行试验，确认解析结果没有问题之后，再应用到策略当中。

### 问财实时数据：query_iwencai (研究环境使用，与网页使用一致)

- 📢 介绍
i问财同花顺旗下的AI投顾平台，是财经领域落地最为成功的自然语言、语音问答系统。

- 👑调用方法：
query_iwencai(query,domain='股票',timeout=6,df=True)

研究环境地址：https://quant.10jqka.com.cn/view/study-research.html

也可以在客户端内访问：量化-研究环境

- 📚参数说明：

| 参数 | 格式 | 说明 |
| --- | --- | --- |
| query | str | 自然语句，语句规范可参考i问财官方网站 |
| domain | str | 可选'股票'、'基金'、'指数'、'新三板'、'港股'、'美股' |
| timeout | int | 超时时间 |
| df | bool | 格式化dataframe |

- 🔧作用：

query_iwencai函数是智能选股函数，可以通过输入自然语言，执行选股并获取股票列表

- ❗注意事项：

该函数可获得和网页版问财相同的结果
该函数支持问财专业版的问句
该函数有调用次数限制，每15分钟内限制调用5000次
该函数不是为回测而设计，回测中慎用

- 📝示例：

query_iwencai("近10日的区间主力资金流向>5000万元，市值>1000亿，日成交额>30亿")
​

### 问财昨日数据：get_iwencai(回测环境使用)

- 📢介绍
backtest是同花顺i问财推出的策略回测服务，可以基于自然语言快速选出每天符合条件的股票池

- 👑调用方法：
get_iwencai(sentence, set_attr, version)

- 📚参数说明：

| 参数 | 格式 | 说明 |
| --- | --- | --- |
| sentence | str | 自然语句，语句规范可参考backtest |
| set_attr | str | 如果该参数不输入,则返回的股票列表默认保存在context.iwencai_securities中 |
| 如果该参数输入'stocks_list'(自定义),则返回的股票列表保存在context.stocks_list中 |  |  |
| version | str | 'stable':稳定版'online':为正式版备注：如果您希望跟问财官网保持一致，请使用'online' |

- 🔧作用：

get_iwencai函数是智能选股函数，可以通过输入自然语言，执行选股并获取股票列表(仅可在股票API策略框架的初始化函数中调用)

- ❗注意事项：

该函数是智能选股函数,属于初始化函数，必须在init函数下设置,否则无效
该函数设置在init函数下时，系统会保存该语句，并使得该函数能每天执行选股，将结果保存至context对象中
该函数的set_attr参数不输入, 则会将返回的股票列表默认保存在context.iwencai_securities中
get_iwencai的选股结果不会直接输出,返回值为空
该函数有调用次数限制，每15分钟内限制调用5000次

- 📝示例一：

def init(context):
    # 输入选股条件
    get_iwencai('净利润增长大于20%,股价位于20日均线上方')

def handle_bar(context, bar_dict):
    # 打印输回测出前一日收盘后的选股结果
    log.info(context.iwencai_securities)
​

- 📝示例二：

# 研究环境中使用get_iwencai
get_iwencai = get_iwencai = get_open_api('public').get_iwencai
stk_pool = get_iwencai('净利润增长大于20%,股价位于20日均线上方','20230701','20230801',version='stable')
​

### 问财接口是否支持本地接口调用？

不支持。supermind 中只有极少的数据支持本地接口调用，详见：https://quant.10jqka.com.cn/view/help/3

### 市面ZUI全！一文讲透问财语句深度使用技巧（含50个案例）

https://quant.10jqka.com.cn/view/article/2183

## 组合优化器

### 构造组合优化

#### 初始化组合优化器

- 👑调用方法：

OptimizePort(stock_return, trade_date, return_expect, opt_focus='UI', benchmark='000905.SH', loss_aversion=0.5, cost=0.003, period='d', holds=0, long_short='long-only')
​

- 📚参数说明：

stock_return：股票预期收益率，支持pd.Series或dict格式

pd.Series格式：index表示股票代码，values为预期收益率
dict格式：key表示股票代码，value为预期收益率

trade_date：str，表示优化日期，例如'2022-12-14'
return_expect： bool，预期收益计算方式

return_expect = True：采用个股历史平均值作为预期收益率
return_expect = False：按stock_return作为预期收益率

opt_focus：str,优化方式

opt_focus='UI'：效用最大化，默认
opt_focus='IR'：为最大信息比率
opt_focus='MVO'：为夏普比率

benchmark：str，基准指数，目前仅支持'000905.SH' (默认)，'000300.SH' 、 '000016.SH' 、'000906.SH'、'000010.SH' 、'000001.SH'
loss_aversion：float，风险厌恶系数，默认为0.5
cost：float，交易成本，默认为0.003
period：str，调仓周期

period='d'：按天调仓
period='w'：按周调仓
period='m'：按月调仓

holds:当前持仓权重，支持pd.Series或dict格式

pd.Series格式：index表示股票代码，values为持仓权重
dict格式：key表示股票代码，value为持仓权重
int(0)：代表没有持仓(默认)

long_short：str，表示是否做空

long_short='long-only'：只能做多
long_short='short-long'：可以做多也可以做空

- 🔧作用：

用来构造组合优化器

- ❗注意事项：

该函数在策略框架函数之外执行
性能分析结果再日志的最后部分显示
func_list参数如果不填写，则默认为分析所有函数

#### 添加约束条件

- 👑调用方法：

```
opt.add_constraint(con_type, args=())
​
```

- 📚参数说明：

stock_return：str，约束类型

stock_return='turnover_target'：换手率约束
stock_return='tracking_error'：跟踪误差约束
stock_return='port_risk'：组合风险约束
stock_return='stock_weight'：个股权重约束
stock_return='special_style'：风格因子暴露度约束
stock_return='industry'：行业因子暴露度约束

args：不同约束类型传的参数不同

stock_return='turnover_target'：输入tuple(换手率上限，换手率下限)，默认为(0.0, 100.0)，100表示100%
stock_return='tracking_error'：输入tuple(跟踪误差下限，跟踪误差上限)，默认为(0.0, inf)
stock_return='port_risk'：输入tuple(组合风险下限，组合风险上限)。默认为(0.0, inf)
stock_return='stock_weight'：输入pd.Series或dict. key为股票代码，value为权重
stock_return='special_style'：输入dict，且key为因子名，value为list: [暴露度下限，暴露度上限]，该约束没有默认值，必须传参数，例如{'size':[0,0.5]}
stock_return='industry'：输入str或dict. 当为str且为'industry_neutralize'时所有行业下限为0，上限为0.1;否则key为行业代码，value为list:[暴露度下限，暴露度上限]，该约束没有默认值，必须传参数，例如{'ci4000000':[0.0, 0.5]}

🔧作用：

- 通过约束类型来添加约束条件

❗注意事项：

- 可同时添加多种约束

#### 组合优化器应用示例

```
# 从中证500中随机选取50股票，模拟中证500走势，周频调仓
# Stratified Sampling 方法优点：
#1.当指数标的过多时，完全复制的资金量要求较高
#2.指数标的中很多股票的成交量过小，交易成本较高，甚至无法完全复制中证500标的成分股权重
import random
def init(context):
    # 设置基准收益：中证500指数
    set_benchmark('000905.SH')
    # 打印日志
    log.info('策略开始运行,初始化函数全局只运行一次')
    # 设置股票每笔交易的手续费为万分之二(手续费在买卖成交后扣除,不包括税费,税费在卖出成交后扣除)
    set_commission(PerShare(type='stock',cost=0.0002))
    # 设置股票交易滑点0.5%,表示买入价为实际价格乘1.005,卖出价为实际价格乘0.995
    set_slippage(PriceSlippage(0.002))
    # 设置日级最大成交比例25%,分钟级最大成交比例50%
    # 日频运行时，下单数量超过当天真实成交量25%,则全部不成交
    # 分钟频运行时，下单数量超过当前分钟真实成交量50%,则全部不成交
    set_volume_limit(0.25,0.5)
    # 从中证500中随机选取50股票
    stocks=random.sample(list(get_index_stocks('000905.SH','2017-12-21')), 50)
    #构建股票列表，形式为dict，以便后续使用组合优化器
    context.security={ia:0 for ia in stocks} 
    #构建初始股票权重
    context.hold={ia:0 for ia in stocks}
    #股票权重限制
    context.weight={ia :[0.0,100.0] for ia in stocks}
    #周频调仓
    run_weekly(func=optmize, date_rule=1, reference_security='000001.SZ')

def optmize(context, bar_dict):
    time=get_datetime().strftime('%Y%m%d')
    #构造组合优化器，优化目标设置为最大化效用，使用历史收益率作为预期收益率
    opt=OptimizePort(context.security, '2017-12-21', True, opt_focus='UI', benchmark='000905.SH', period='w', holds=context.hold, long_short='long-only')
    opt.add_constraint('stock_weight',context.weight)
    #添加跟踪误差约束
    opt.add_constraint('tracking_error',(-0.02,0.02))
    # opt.add_constraint('industry','industry_neutralize')
    #使用组合优化器进行求解
    stock_weight = opt.optimized_weight()
    #根据组合优化器结果进行权重调整
    for ia in stock_weight.keys():
        order_target_percent(ia, stock_weight[ia]/100)
​
```

## 官方交流群

### 注意此群为交流群，如果有疑问请在论坛发帖 ，点此发帖

🌎加入SuperMind官方微信群交流

上一节下一节
需要帮助？试试AI小助手吧